## 初始化

变量在被定义的同时获得了一个特定的值，这个值可以是任意复杂的表达式。

**初始化 != 赋值：**赋值的含义是把对象的当前值擦除，用一个新值来代替。



### 列表初始化

不允许窄缩转换，比如将float类型的变量赋值给int型变量时，会丢失精度，此时无法使用列表初始化。

> **初始化的四种写法**
>
> ```c++
> int obj = 0;
> int obj = {0};
> int obj(0);
> int obj{0};
> ```



### 默认初始化

变量在定义时没有指定初值时被默认初始化。

- 若为内置类型且定义在函数体之外，则初始化为0，此时为全局变量，位于全局/静态区；

- 若定义在函数体内，则不执行初始化（uninitialized），此时任何访问它的行为都会被报错。

**定义在函数体内的内置类型变量未被初始化时，其值是未定义的（undefined）；类类型的对象未被显式初始化时，其默认初始值由类自己决定。**





## 变量的声明与定义

变量的声明规定了变量的类型和名字，从这一点上看声明和定义是相同的。但是除此之外，变量的定义还会申请储存该变量的内存空间，也可能会为变量默认初始化一个初始值。**变量可被定义一次，但可以多次声明。**



### extern关键字

若只是想声明一个变量而非定义它，需要使用**extern**关键字。**extern**置于变量或函数前，以标识变量或函数的定义在其他文件中，提示编译器在遇到该变量或函数时去其他文件寻找其定义。

- 任何包含显式初始化的声明都是定义，比如在使用**extern**关键字的同时对声明的变量进行显式初始化；
- **extern**标记的变量应该是**可被外部文件共享的全局变量**，只有这样才有它的意义；
- 在函数体内部，如果试图初始化一个**extern**修饰的变量，将引发错误。（这么做等于定义一个被外部访问的局部变量，无任何意义。）





## 左值引用

**左值引用**等于给变量起别名，**引用不是对象**，它只是一个**已存在对象的别名**。因此，**无法定义引用的引用。**

**左值引用**只能绑定到对象上，而不能与字面值、某个表达式的计算结果，一般函数返回值绑定到一起（**右值引用**）。

> **引用为什么必须初始化？**
>
> 变量在初始化时，初始值会被拷贝至新建对象的内存空间。定义引用时，只是把引用和它的初始值绑定在一起，**而不是将初始值拷贝给引用**。一旦初始化完成，引用将永远与它的初始值对象绑定在一起，无法再将引用绑定到另一个对象上。**因此引用在定义的时候必须初始化。**





## 指针

与引用不同，指针本身是一个对象，因此定义时无须初始化，但是未初始化的指针将拥有一个不确定的初值；此外，在指针的生命周期期间，可以先后指向不同的对象。

**由于引用不是对象，没有实际地址，因此不能将指针指向一个引用。**



### 指针值的四种状态

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针nullptr
4. 无效指针（野指针），即上述情况外的其他非法值



### 指针间的比较

若两指针存放的内存地址相同，则比较结果为真。



### void*指针

void类型的指针可以存放任意对象的地址。但是由于不知道存放对象的类型，因此不知道所指对象能进行什么操作，所以**无法使用void指针操作其指向的对象。**



### 指向指针的引用

由于指针是一个对象，因此存在对指针的引用。

```C++
int i = 42;
int *p = nullptr;
int *&r = p;  //从右往左阅读，r是一个对指针p的引用，即指针p的别名

r = &i;  //将指针p指向变量i
*r = 0;  //将指针p指向的变量的值赋值为0
```





## const限定符

由于const对象一经创建就不能再被改变，因此const对象必须初始化。

**默认状态下，const只在定义它的文件内有效，若想在多个文件中共享const变量，那么不管是声明还是定义，都需要加extern关键字修饰。**



### const修饰引用

**常量引用 恒等于 对const的引用**

类似于对常量起别名。与普通引用不同的是，常量引用初始化时可以使用任意表达式做初始值，只要该表达式的结果能转换成引用的类型即可。**特别地，常量引用允许字面值（右值）对其进行初始化。**

> **为什么常量引用可以使用右值初始化？**
>
> ```C++
> const int &ri = 666;
> ```
>
> 当编译器执行上述语句时，会自动创建一个**临时量对象**，即：
>
> ```C++
> const int tmp = 666;
> const int &ri = tmp;
> ```
>
> 若ri没有用const修饰，即如果左值引用可以用右值初始化的话，那么就能通过ri去修改ri所引用的对象的值，然而实际更改的是临时量的值，这无疑是没有任何意义的，因此**普通引用不能用右值进行初始化**。然而对常量引用而言，常量引用不能改变所绑定对象的值，那么临时量的值也不会被修改。因此**可以使用右值对常量引用进行初始化。**



### const修饰指针

#### 指向常量的指针

不能通过该指针改变所指向对象的值，但可以指向别的对象。

```C++
const int ci = 5;
const int cj = 10;
const int *pt = &ci;
++(*pt); // 非法,不能通过指向常量的指针修改所指对象的值
pt = &cj; // 合法,可以指向别的常量

int ia = 7;
pt = &ia; // 合法,可以指向任何同类型对象,只不过不能通过该指针修改它们的值而已
```



#### 常量指针

可以通过指针修改所指对象的值，但指针不可以再指向别的对象，因此**必须初始化**。

```c++
int ia = 5;
int ib = 7;
int *const pt = &ia;
++(*pt); // 合法,可以修改所指对象的值
pt = &ib; // 非法,不能再指向别的对象
```



### 顶层/底层const

这个概念仅在执行**拷贝操作**时有所区分。

**指针本身是不是常量与指针所指向的对象是不是常量是两个相互独立的问题。**

- 若指针本身是一个常量，即**常量指针**，那么指针具有**顶层const**
- 若指针指向了一个常量，即**指向常量的指针**，那么指针具有**底层const**

更一般地，

- 只要任意的对象是常量，那么它就具有**顶层const**
- 只有**指针或引用**会具有**底层const**
- **常量引用都是底层const**



**在执行拷贝操作时，顶层const对拷贝过程没什么影响，可忽略。**当拷贝对象具有底层const时，被拷贝对象也必须同样具有底层const。若被拷贝对象无底层const，则二者的数据类型必须能转换。即非常量可以转换为常量。

```C++
int i = 0;
int *const p1 = &i; // 顶层const
const int ci = 42; // 顶层const

const int *p2 = &ci; // 底层const
const int *const p3 = p2; // 拥有底层和顶层const
const int &r = ci; // 底层const

i = ci; // 赋值操作,被拷贝对象具有顶层const,不影响拷贝
p2 = p3; // 底层const,可以拷贝具有底层const的对象,被拷贝对象的顶层const不影响
p2 = &i; // 底层const,i本身是非常量,但是非常量可以转换成常量
```





## 常量表达式

在**编译期就能确定且不会被改变**的值（如字面值）。一个对象/表达式是不是常量表达式由它的数据类型和初始值共同决定。若变量的值需要到运行期才能确定，那么它就不是一个常量表达式。



### constexpr关键字

该关键字可以让编译器在编译期判断它修饰的变量是不是常量表达式，若不是则报错。因此，若想用常量表达式初始化变量，那么应该使用**constexpr**进行修饰。



#### 字面值类型

具体地，constexpr类型的变量必须通过**字面值类型**进行初始化。基本数据类型，引用，指针都是字面值类型，而自定义类型，IO库，string类等则不是。特别地，对constexpr指针的初始化必须用nullptr或**存储于固定地址中的对象**进行。

> **存储在固定地址的对象？**
>
> 全局变量，全局静态变量，局部静态变量都符合；所有定义在函数体内部的临时变量则不是。

**constexpr修饰指针时，只对指针本身有效，即赋予指针顶层const属性。**

```c++
const int *p = nullptr;     // 指向常量的指针
constexpr int *q = nullptr; // 常量指针
constexpr const int *t = nullptr; // 可以指向常量的常量指针
```





## 类型别名

C++创建类型别名的方式有两种：

- 直接使用define来创建，这样创建的别名在预处理期就会被文本替换；
- 使用typedef/using来创建，此时创建的别名是一个新类型。

对于非指针类的变量，直接文本替换为原始类型进行理解即可，若变量是指针类型，则需注意：

```c++
typedef char* pstring; // pstring是指向char的指针类型，即基本类型pstring是指针
using pstring = char*; // 等价

const pstring p1 = nullptr; // p1是指向char类型的常量指针
const pstring p2;  // p2是指向char指针类型的常量指针
```

> **为什么会出现上述这种情况？**
>
> 变量的定义语句由 **基本数据类型 + 声明符** 组成。对于下面这样的语句：
>
> ```c++
> char *pa = nullptr;
> ```
>
> 此时基本数据类型为char，*和pa共同组成声明符，此时pa是一个指针，指向char类型；
>
> ```c++
> using cp = char*;
> const cp pb = nullptr;
> ```
>
> 使用别名声明后，变量pb的定义语句中，const cp是基本数据类型，pb独自组成声明符，因此pb是指向char的常量指针。





## auto与decltype

### auto

使用auto初始化变量时，用于初始化的变量的顶层const被忽略，而底层const被保留。若引用被用作初始化值，那么使用被引用的对象值进行初始化。

```c++
const int ci = 0, &cr = ci;
auto a = ci; // type: int
auto b = cr; // type: int
auto c = &ci; // type: 一个指向整形常量的指针(保留底层const)
```

当使用auto初始化引用时，则初始值中的顶层const被保留。

```c++
const int ci = 0;
auto &ra = ci; // type: const int
```



### decltype

**选择并返回操作数的数据类型。**编译器只分析表达式的类型，而不具体地计算它。

```c++
decltype(f()) sum = x; // sum的类型是函数f的返回类型，但推断时并没有执行函数f
```

与auto不同的是，若decltype使用的表达式是一个变量，那么变量的**顶层const和底层const都不会被忽略**。

```c++
const int ci = 0;
const int &cj = ci;

decltype(ci) x = 0; // type: const int
decltype(cj) y = x; // 常量引用
decltype(cj) z;     // error: z is a reference type, must be initialized.
```

**引用只作为其所指对象的别名存在，只有用在decltype时除外。**

当decltype使用的表达式不是一个变量，则返回表达式的结果对应的类型。特别地，若表达式的内容是**解引用操作**，那么decltype得到的类型是**引用类型**。

```c++
int i = 42, *p = &i;
decltype(*p) c; // error: c is a referencce type, must be initialized.
```

> 对指针进行解引用操作后会得到该指针指向的对象，解引用返回的对象可以作为左值被赋值，此时decltype的推断结果是引用类型。

**若变量名加上一对括号()，那么编译器会将它当做表达式。变量是可以作为赋值语句左值的特殊表达式，因此decltype会得到引用类型。**

特别地，**赋值是会产生引用的一类典型表达式。**

```c++
decltype(variable) x; // x只有在variable本身是个引用时才是引用
decltype((variable)) y; // 无论variable是何类型，y都是引用

int i;
decltpe(i = 1) z; // z是int&类型
```

